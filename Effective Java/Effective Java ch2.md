## 2. 객체의 생성과 파괴

### 1. 생성자 대신 정적 팩토리 메서드 패턴을 고려하라.
-   **명확한 정적 팩토리 메서드 명**: 명확한 역할 표현.
-   **재사용 가능**: 항상 새로운 객체를 생성할 필요 없음, 예: 싱글톤.
-   **하위 타입 반환 가능**: 입력에 따른 다양한 반환 유형.
-   **유연한 객체 생성**: 작성 시점에 **반환할 객체의 클래스**를 몰라도 됨.
-   **단점**: 생성자에 비해 함수 발견이 어려움.
-   **네이밍 컨벤션 예**: `from`, `of`, `valueOf`, `instance`, `create`, `getType`, 등.

<br>

### 2. 생성자에 매개변수가 많다면 빌더를 고려하라.

-   **점진적 생성자의 복잡성**과 **setter를 이용한 불안정한 객체 상태** 방지.
-   가독성 향상, 선택적 매개변수 관리 용이

<br>

### 3. private 생성자나 열거형으로 싱글톤임을 보증하라.

-   **싱글턴 구현 방식**
	-  private 생성자와 public static 필드 또는 함수.
	- 원소가 하나인 열거형.

<br>

### 4. 인스턴스화를 막으려거든 private 생성자를 사용하라.

-   정적 필드나 메소드만 있는 클래스의 경우, private 생성자 이용.

<br>

### 5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.

-   필요한 자원을 외부에서 주입 받아 사용. 예: Spring DI.

<br>

### 6. 불필요한 객체의 생성을 피하라.

-   재사용 가능한 객체는 최대한 재사용. (특히 불변 객체나 객체의 불변을 보장할 수 있는 경우)
-   의도치 않은 오토박싱 주의

<br>

### 7. 다 쓴 객체 참조를 해제하라.

-   객체 범위 벗어남으로써 메모리 해제가 가장 이상적임.
-   메모리 관리와 직접적으로 연관된 클래스는 주의 : Stack, Cache 등.
-   필요 시 null 처리.
-   WeakHashMap.

<br>

### 8. finalizer와 cleaner 사용을 피하라.

-   객체를 없애주는 finalizer와 cleaner는 수행 시점이나 수행 여부의 불확실성이 존재.
-   대신 `close` 메서드와 `AutoCloseable` 인터페이스 사용.
	-   `close`는 객체의 상태를 닫힘으로 설정하여 이용되지 못하게 함.

<br>

### 9. try-finally 보다는 try-with-resources를 사용하라.

-   `AutoCloseable` 구현하여 이용.
-   코드 간결성 및 예외 정보의 유용성 증가.
